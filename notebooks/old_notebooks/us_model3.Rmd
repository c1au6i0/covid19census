---
title: 'Report on Interference: US data'
author: "C1au6i0 & Marchionni Lab"
date: "`r Sys.Date()`"
output: 
  bookdown::pdf_document2:
    latex_engine: xelatex
    fig_caption: yes
    df_print: kable
header-includes:
 \usepackage{float}
  \floatplacement{figure}{H}
---

# Data Preprocessing

## **Summary**

  *  got the update data using `covid19census::getus_all(repo = "jhu")`
  *  calculated some percentage (`age65_over`, `perc_black`, `perc_white`, `perc_lat`), `total_tests` and, days from first case (`days_f0`)
  *  filtered for selected variables (the list `to_select` was populated by removing Pearson's correlations >= .8 in the same domain and across, *analysis not included*)
  *  percentages multiplied by 100, **filtered death >= 1** 
  *  add a prefix to variables:
      * `ZZ` = `perc_imm65`
      * `logitZZ` =  `perc_imm65` predicted probability: log(p/(1 âˆ’ p))
      * `YY` = dependent variable `deaths`
      * `NC` = number of cases: `cases`
      * `NP` = population: `total_pop`
 *  filtered to get only the aggregated data (last date).

The dataframe `all_dat` lists all variables by date, whereas `today_dat` only the most recent endpoint.



https://data.census.gov/cedsci/table?q=race&tid=ACSDP1Y2018.DP05&hidePreview=true&moe=false&g=0500000US05031

## Get Data and Make Them Tidy

```{r libs, message=FALSE, warning=FALSE}
# devtools::install_github("c1au6i0/covid19census_dev", auth_token = "8ca5cd2bb556a45f1ffeb2e9b44c90d4fbef6cf2", ref = "dev")
# # devtools::install_github("zeehio/facetscales")

library(facetscales)
library(covid19census)
library(tidyverse)
library(ggcorrplot)
library(caret)
library(GGally)
library(gganimate)
library(ggcorrplot)
library(ggdendro)
library(broom)
library(purrr)
library(knitr)
library(kableExtra)
library(htmlwidgets)
library(plotly)
theme_set(theme_bw())
```

This is the list of variable that we are going to select.

```{r to_select_b}
to_select <- c(
  "date",
  "county",
  "state",
  "fips",
  "cases",
  "deaths",
  "perc_families",
  "perc_familes_18childreen",
  "perc_married_couples",
  # "perc_married_couples_u18ychildreen",
  "perc_families_only_male",
  # "perc_families_only_male__18ychildreen",
  "perc_families_only_female",
  # "perc_families_only_female__18ychildreen",
  # "perc_non_families_alone",
  # "perc_non_families_alone65y",
  # "perc_non_families_u18y",
  # "perc_non_families_65y",
  # "perc_relationship_householder",
  # "perc_relationship_spouse",
  # "perc_relationship_child",
  # "perc_relationship_other_relatives",
  # "perc_relationship_other_nonrelatives",
  # "perc_relationship_other_unmaried_part",
  # "perc_marital_status_male_nevermaried",
  # "perc_marital_status_male_maried",
  # "perc_marital_status_male_separated",
  # "perc_marital_status_male_widowed",
  # "perc_marital_status_male_divorced",
  # "perc_marital_status_female_nevermaried",
  # "perc_marital_status_female_maried",
  # "perc_marital_status_female_separated",
  # "perc_marital_status_female_widowed",
  # "perc_marital_status_female_divorced",
  "perc_enrolled_preschool",
  "perc_enrolled_kindergarden",
  "perc_enrolled_elementary",
  "perc_enrolled_highschool",
  "perc_enrolled_college",
  # "perc_edu_9grade",
  # "perc_edu_nodiploma",
  # "perc_edu_highshool",
  "perc_edu_somecollege",
  "perc_edu_associate",
  "perc_edu_bachelor",
  # "perc_edu_gradprofess",
  # "perc_edu_highshool_higher",
  # "perc_edu_batchelor_higher",
  "perc_american",
  "perc_arab",
  "perc_czech",
  "perc_danish",
  "perc_dutch",
  "perc_english",
  "perc_french_except_basque",
  "perc_french_canadian",
  "perc_german",
  "perc_greek",
  "perc_hungarian",
  "perc_irish",
  "perc_italian",
  "perc_lithuanian",
  "perc_norwegian",
  "perc_polish",
  "perc_portuguese",
  "perc_russian",
  "perc_scotch_irish",
  "perc_scottish",
  "perc_slovak",
  "perc_subsaharan_african",
  "perc_swedish",
  "perc_swiss",
  "perc_ukrainian",
  "perc_welsh",
  "perc_west_indian_excluding_hispanic_origin_groups",
  # "perc_withcomputer",
  "perc_withinternet",
  "total_pop",
  "perc_imm65",
  "total_beds",
  "urban",
  "perc_acute_myocardial_infarction",
  "perc_alzheimer_dementia",
  "perc_asthma",
  "perc_atrial_fibrillation",
  "perc_cancer_breast",
  "perc_cancer_colorectal",
  "perc_cancer_lung",
  "perc_cancer_all",
  "perc_ch_obstructive_pulm",
  "perc_chronic_kidney_disease",
  "perc_depression",
  "perc_diabetes",
  "perc_heart_failure",
  "perc_hypertension",
  "perc_ischemic_heart_disease",
  "perc_obesity",
  "perc_osteoporosis",
  "perc_rheumatoid_arthritis",
  "perc_schizophrenia_psychotic_dis",
  "perc_stroke",
  "perc_tobacco_use",
  # to many NA for these:
  # "urgent_admission",
  # "annual_wellness_visit",
  # "elective_admission",
  # "emergent_admission",
  # "other_admission",
  # perc_pneumococcal_vaccine HIGHLY CORRELATED WITH perc_imm65
  # "perc_pneumococcal_vaccine",
  # "perc_poverty",
  "median_income",
  "pm2.5",
  "summer_temp",
  "summer_hum",
  "winter_temp",
  "winter_hum",
  "age65_over",
  "median_age",
  # "median_age_male",
  # "median_age_female",
  "sex_ratio",
  # "age_dependency",
  # "old_age_dependency",
  "child_dependency",
  "perc_black",
  "perc_lat",
  "perc_white",
  "total_tests",
  "days_f0"
)
```

We get the data and preprocess them as described in the summary.

```{r warning=FALSE}
df1 <- getus_all()

df2 <-
  df1 %>%
  # calculate age65_over and perc_black, white and latinos, total tests
  mutate(age65_over = rowSums(dplyr::select(., matches("perc_[6][5-9]|[7|8][0-9]")))) %>%
  mutate(urban = if_else(urban == "Urban", 1, 0)) %>%
  mutate(perc_black = total_black / total_pop * 100) %>%
  mutate(perc_white = total_white / total_pop * 100) %>%
  mutate(perc_lat = total_latino / total_pop * 100) %>%
  mutate(total_tests = positive + negative) %>%

  # calculate day since first case
  mutate(f_date = case_when(cases >= 1 ~ date)) %>%
  group_by(fips) %>%
  mutate(f_date = min(f_date, na.rm = TRUE), days_f0 = as.numeric(date - f_date)) %>%
  ungroup() %>%
  mutate(days_f0 = if_else(is.finite(days_f0), days_f0, NA_real_)) %>%

  # select variables
  dplyr::select(!!to_select) %>%

  # perc divided by 100
  mutate_at(vars(starts_with("perc")), function(x) x / 100) %>%
  mutate(age65_over = age65_over / 100) %>%

  # we remove NAs
  na.omit() %>%

  # at least 1 death
  filter(deaths >= 1)

all_dat <- df2 %>%
  # make variables numeric
  mutate_at(vars(
    -date, -county, -state, -fips, -cases, -deaths,
    -perc_imm65, -cases, -total_pop
  ), as.numeric) %>%
  # rename
  # add XX_ to all the variables excepts those
  rename_at(
    vars(
      -date, -county, -state, -fips, -cases, -deaths,
      -perc_imm65, -cases, -total_pop
    ),
    ~ paste0("XX_", .)
  ) %>%
  rename_at(vars(perc_imm65), ~ paste0("ZZ_", .)) %>%
  rename_at(vars(deaths), ~ paste0("YY_", .)) %>%
  rename_at(vars(cases), ~ paste0("NC_", .)) %>%
  rename_at(vars(total_pop), ~ paste0("NP_", .)) %>%
  # calculate logitZZ
  mutate(logitZZ = log(ZZ_perc_imm65) - log(1 - ZZ_perc_imm65))

today_dat <- all_dat %>%
  filter(date == max(date))

dim(today_dat)
```

# Models

## **Summary of Results of Modeling**

## Propensity Score Analysis

First, we calculate the propensity score.

```{r prop_score_formula}
# with this we create the formula:
# we get all the variables that start with XX
XX <- grep("XX", names(today_dat), value = TRUE)

# XX <- XX[XX != "XX_total_tests" ]
# XX <- c("NP_total_pop", XX)

form_ps <- reformulate(termlabels = XX, response = "logitZZ")

# in lm we input the formula
PropScoresLM <- lm(form_ps, data = today_dat)
tidy(PropScoresLM) %>%
  mutate(term = str_sub(term, 1, 27))
#
# %>%
#   kable( "latex", booktabs = TRUE, longtable = TRUE) %>%
#   kable_styling(latex_options = c("hold_position", "repeat_header"))
``` 

Then, we use the propensity score in the linear model using `YY_deaths` as response. 

```{r model_cases}
outcomePP_cases <-
  today_dat %>%
  # we add on the fly PP to the dataframe
  mutate(PP = fitted.values(PropScoresLM)) %>%
  glm(YY_deaths ~ ZZ_perc_imm65 + PP,
    family = quasipoisson(link = "log"),
    offset = log(NC_cases), data = .
  )

tidy(outcomePP_cases)
``` 

 

**How did the slope of the `ZZ_perc_imm65` change overtime?** 

The code below is used to fit the model to data obtained at different endpoints. The idea behind this analysis is to get a sense of how stable is the effect observed (it could well be the result of a fluke in today data).

```{r  message=FALSE, warning=FALSE}
# we create a function that we apply to the nests
get_PPScore <- function(dat = .x, filt_cases = 1, form = form_ps, offset_f = "log(NC_cases)") {
 
  dat <- dat %>%
    filter(dat$NC_cases >= !!filt_cases)
  
  PropScoresLM <- lm(form, data = dat)

  outcome_PP <-
    # we add on the fly PP to the dataframe and we
    dat %>%
    mutate(PP = fitted.values(PropScoresLM)) %>%
    glm(YY_deaths ~ ZZ_perc_imm65 + PP,
      family = quasipoisson(link = "log"),
      offset = eval(parse(text = offset_f)), data = .
    )

  res <- tidy(outcome_PP) %>%
    filter(term == "ZZ_perc_imm65") %>%
    mutate(
      deaths = sum(dat$NC_cases),
      n_counties = nrow(dat),
      urban = sum(dat$XX_urban)
    )
  
  
 message(
   "Applying model with filt_cases = ",
   paste0(filt_cases))
 
 res
}

# Here we select some dates, we nest the dataframe and we
# use mutate to apply the model to each nest subset.
# This is the equivalent of splitting a dataframe by date, lapply
# the formula to the list of dataframes, and cbind the results.
# dplyr + broom

dates_tostudy <- sort(unique(all_dat$date))[52:length(unique(all_dat$date))]
to_filt_cases  <- seq(1,100, 1)                                     

zz_term <-   
  all_dat %>%
  filter(YY_deaths > 0) %>% 
  filter(date %in% dates_tostudy) %>%
  nest(-date) %>%
  slice(rep(1:n(), each = length(to_filt_cases))) %>% 
  mutate(filt_cases_c = rep(to_filt_cases, nrow(.)/length(to_filt_cases))) %>% 
  mutate(fit = 
            map2(
            data,
            filt_cases_c,
            get_PPScore,
            form = form_ps, 
            offset_f = "log(NC_cases)"
            )
  ) %>% 
    unnest(fit)


# we keep a version without data that takes a lot of space
zz_term_nd <- zz_term %>% 
  select(-data)
```


  
```{r pscases, fig.cap="propensity score, NC_cases as offset", fig.width=4, fig.height=4, warning=FALSE}  
zz_term_nd %>%
  filter(filt_cases_c == 1) %>% 
  mutate(`urban/counties` = urban/n_counties) %>% 
  rename(`number of counties` = n_counties) %>% 
  pivot_longer(cols = 
                 c("estimate", "number of counties", "urban/counties"),
               names_to = "var_name") %>%
  mutate(sign = if_else(p.value < 0.05, "p<0.05", "NS")) %>%
  mutate(std.error = if_else(var_name == "estimate", std.error, 0)) %>% 
  
  ggplot(aes(date, value, color = sign, group = term)) +
      geom_line() +
      geom_point() +
      geom_linerange(aes(ymax = value + std.error, ymin = value - std.error), show.legend = FALSE) +
      scale_color_manual(values = c("#00BFC4", "#F8766D")) +
      facet_grid(vars(var_name), scales = "free") +
      theme( 
        # legend.position = "top",
        legend.title = element_blank(),
        legend.box.background = element_rect(colour = "black")
      ) +
      labs(
        title = "Slope of ZZ_perc_imm65 over time",
        subtitle = "cases > 0, propensity score  using number of cases as offset"
      )
```

The var `estimate` represents the slope of `ZZ_perc_imm65`, whereas `n_counties` is the number of counties included in the analysis (only counties with at least one death can be included). The color of the points indicates if slope was significantly different from 0.
Before Apr 20, slope of `ZZ_perc_imm65` was occasionally significant but pattern was very erratic.


```{r filt_graph. fig.width=4, fig.height=4}
zz_term_nd %>%
  filter(date == max(date)) %>% 
  mutate(`urban/counties` = urban/n_counties) %>% 
  rename(`number of counties` = n_counties) %>% 
  pivot_longer(cols = 
                 c("estimate", "number of counties", "urban/counties"),
               names_to = "var_name") %>%
  mutate(sign = if_else(p.value < 0.05, "p<0.05", "NS")) %>%
  mutate(std.error = if_else(var_name == "estimate", std.error, 0)) %>% 
    
  
  ggplot(aes(filt_cases_c, value, color = sign, group = term)) +
      geom_line() +
      geom_point() +
      scale_color_manual(values = c("NS" = "#00BFC4", "p<0.05" = "#F8766D")) +
      geom_linerange(aes(ymax = value + std.error, ymin = value - std.error), show.legend = FALSE) +
      facet_grid(vars(var_name), scales = "free") +
      theme(
        # legend.position = "top",
        legend.title = element_blank(),
        legend.box.background = element_rect(colour = "black")
      ) +
      labs(
        title = paste0(max(zz_term_nd$date),": Slope of ZZ_perc_imm65"),
        subtitle = "propensity score  using number of cases as offset",
        x = "minimum cases per county to be included in analysis" 
      )
```



```{r}
today_dat %>% 
  filter(!is.na(XX_urban)) %>% 
  ggplot(aes(XX_urban, YY_deaths, col = state, cases = NC_cases, county = county)) +
  theme(legend.position = "none") +
    geom_jitter()
```
```{r}
today_dat %>% 
  filter(!is.na(XX_urban)) %>% 
  mutate(XX_urban = recode(
    XX_urban,
    `1` = "urban",
    `0` = "rural"
    )) %>% 
  ggplot(aes(XX_urban, ZZ_perc_imm65, group = XX_urban)) +
  theme(legend.position = "none") +
  scale_x_discrete() +
  geom_boxplot() +
  labs(
    y = "Vaccination coverage in people age 65 or older",
    x = NULL
    )
    
```

```{r}
(ggplot(today_dat,aes(ZZ_perc_imm65, YY_deaths, colour = XX_urban, county = county, shapes = XX_urban)) +
    theme(legend.position = "none") +
    geom_jitter()) %>% 
  ggplotly()
```


We make an animation for doing the same analysis on all dates.

```{r filt_graph}
zz_term_nd %>%
  mutate(`ratio urban counties` = urban/n_counties) %>% 
  rename(`number of counties` = n_counties) %>% 
  pivot_longer(cols = 
                 c("estimate", "number of counties", "ratio urban counties"),
               names_to = "var_name") %>%
  mutate(sign = if_else(p.value < 0.05, "p<0.05", "NS")) %>%
  mutate(std.error = if_else(var_name == "estimate", std.error, 0)) %>% 
    
  
  ggplot(aes(filt_cases_c, value, color = sign, group = term)) +
      geom_line() +
      geom_point() +
      scale_color_manual(values = c("#00BFC4", "#F8766D")) +
        geom_linerange(aes(ymax = value + std.error, ymin = value - std.error), show.legend = FALSE) +
      facet_grid(vars(var_name), scales = "free") +
      theme(
        # legend.position = "top",
        legend.title = element_blank(),
        legend.box.background = element_rect(colour = "black")
      ) +
  # gganimate part
      labs(
        title = 'Slope of ZZ_perc_imm65, date results: {current_frame}',
        subtitle = "propensity score  using number of cases as offset",
        x = "Number of cases to be included in analysis"
      ) +
   transition_manual(date)

anim_save("filth_death.gif")
```


```{r pspop, fig.cap="propensity score, NC_cases as offset", fig.width=4, fig.height=4, warning=FALSE} 

dates_tostudy <- sort(unique(all_dat$date))[52:length(unique(all_dat$date))]
to_filt_cases  <- seq(1,100, 1)                                     

zz_term2 <-   
  all_dat %>%
  filter(YY_deaths > 0) %>% 
  filter(date %in% dates_tostudy) %>%
  nest(-date) %>%
  slice(rep(1:n(), each = length(to_filt_cases))) %>% 
  mutate(filt_cases_c = rep(to_filt_cases, nrow(.)/length(to_filt_cases))) %>% 
  mutate(fit = 
            map2(
            data,
            filt_cases_c,
            get_PPScore,
            form = form_ps, 
            offset_f = "log(NP_total_pop)"
            )
  ) %>% 
    unnest(fit)


# we keep a version without data that takes a lot of space
zz_term_nd2 <- zz_term2 %>% 
  select(-data)


zz_term_nd2 %>%
  filter(filt_cases_c == 1) %>% 
  mutate(`urban/counties` = urban/n_counties) %>% 
  rename(`number of counties` = n_counties) %>% 
  pivot_longer(cols = 
                 c("estimate", "number of counties", "urban/counties"),
               names_to = "var_name") %>%
  mutate(sign = if_else(p.value < 0.05, "p<0.05", "NS")) %>%
  mutate(std.error = if_else(var_name == "estimate", std.error, 0)) %>% 
  
  ggplot(aes(date, value, color = sign, group = term)) +
      geom_line() +
      geom_point() +
      geom_linerange(aes(ymax = value + std.error, ymin = value - std.error), show.legend = FALSE) +
      scale_color_manual(values = c("#00BFC4", "#F8766D")) +
      facet_grid(vars(var_name), scales = "free") +
      theme( 
        # legend.position = "top",
        legend.title = element_blank(),
        legend.box.background = element_rect(colour = "black")
      ) +
      labs(
        title = "Slope of ZZ_perc_imm65 over time",
        subtitle = "cases > 0, propensity score  using number of cases as offset"
      )
```



# Let's redo everything using variable as indicated

## Get Data


## Sanity Checks

### Race


```{r fig.height=7, fig.width=5}

reorder_within <- function(x, by, within, fun = mean, sep = "___", ...) {
  new_x <- paste(x, within, sep = sep)
  stats::reorder(new_x, by, FUN = fun)
}

scale_x_reordered <- function(..., sep = "___") {
  reg <- paste0(sep, ".+$")
  ggplot2::scale_x_discrete(labels = function(x) gsub(reg, "", x), ...)
}

df1 %>% 
  filter(date == max(date)) %>% 
  group_by(state) %>% 
  summarize(
    state_pop = sum(total_pop, na.rm = TRUE),
    perc_black = sum(total_black, na.rm = TRUE) / state_pop  * 100,
    perc_white = sum(total_white, na.rm = TRUE) / state_pop  * 100,
    perc_lat = sum(total_latino, na.rm = TRUE) / state_pop  * 100,
    perc_asian = sum(total_asian, na.rm = TRUE) / state_pop  * 100,
    perc_island = sum(total_pacific_islander, na.rm = TRUE) / state_pop  * 100,
    perc_native = sum(total_native, na.rm = TRUE) / state_pop  * 100,
    perc_other = sum(total_other_race, na.rm = TRUE) / state_pop  * 100,
    perc_two_more_races = sum(total_two_more_races, na.rm = TRUE) / state_pop  * 100) %>% 
  arrange(perc_asian) %>% 
  ungroup(state) %>% 
  
  pivot_longer(
    cols = 
      c("perc_black",
        "perc_lat",
        "perc_white",
        "perc_asian",
        "perc_island",
        "perc_native",
        "perc_other",
        "perc_lat"
        
        ), 
    names_to = "var",
    values_to = "value"
    ) %>% 
  filter(state != "District of Columbia") %>% 
 
  ggplot(aes(reorder_within(state, value, value), value)) +
    geom_col() +
    facet_wrap(vars(var), nrow = 4, scales = "free") +
    scale_x_reordered(guide = guide_axis(check.overlap = TRUE, angle = 45)) +
    labs(x = NULL, y = NULL)
    
```

NOW WE ARE TALKING

```{r}
 df1 %>% 
  filter(date == max(date)) %>% 
  group_by(state) %>% 
  summarize(
    state_pop = sum(total_pop, na.rm = TRUE),
    perc_black = sum(total_black, na.rm = TRUE) / state_pop  * 100,
    perc_white = sum(total_white, na.rm = TRUE) / state_pop  * 100,
    perc_lat = sum(total_latino, na.rm = TRUE) / state_pop  * 100,
    perc_asian = sum(total_asian, na.rm = TRUE) / state_pop  * 100,
    perc_island = sum(total_pacific_islander, na.rm = TRUE) / state_pop  * 100,
    perc_native = sum(total_native, na.rm = TRUE) / state_pop  * 100,
    perc_other = sum(total_other_race, na.rm = TRUE) / state_pop  * 100,
    perc_two_more_races = sum(total_two_more_races, na.rm = TRUE) / state_pop  * 100) %>% 
  
 mutate(
   tot_race = perc_black  + 
         perc_white + 
         perc_asian + 
         perc_island +
         perc_native +
         perc_other +
        perc_two_more_races
   ) %>% 
  select(state, 
         tot_race, 
         perc_black  , 
         perc_white , 
         perc_asian , 
         perc_island ,
         perc_native ,
         perc_other ,
        perc_two_more_races
         )
```



https://data.census.gov/cedsci/table?q=race&tid=ACSDP1Y2018.DP05&hidePreview=true&moe=false&g=0500000US05031


** Population OK **

```{r}
options(scipen = 999)

df2 %>% 
  ggplot(aes(state, total_pop/10^6)) +
   geom_boxplot() +
   scale_x_discrete(guide = guide_axis(check.overlap = TRUE, angle = 45))
```

If we add total latino + total not latinos and we divided by total_pop we get 1...so
this is good


### Hospital Beds

```{r fig.height=6, fig.width=5}
df2 %>% 
  filter(date == max(date)) %>% 
  group_by(state) %>% 
  summarize(
    total_pop_thousand = sum(total_pop, na.rm = TRUE)/1000,
    total_beds = sum(total_beds, na.rm = TRUE),
    ratio_beds = total_beds / (total_pop_thousand * 1000)
    ) %>% 
  arrange(ratio_beds) %>% 
  mutate( state = factor(state, levels = state)) %>% 
  
  pivot_longer(
    cols = c("total_pop_thousand", "total_beds", "ratio_beds"), 
    names_to = "var",
    values_to = "value"
    ) %>% 
  mutate(var = factor(var, levels = c("total_pop_thousand", "total_beds", "ratio_beds"))) %>% 
  
  ggplot(aes(state, value)) +
    geom_col() +
    facet_wrap(vars(var), nrow = 3, scales = "free_y") +
    scale_x_discrete(guide = guide_axis(check.overlap = TRUE, angle = 45)) +
    labs(x = NULL)
```


What is the take home message? That regardless, we are going to have some correlation. So that is why we need to do a propensity score analysis





## PP

```{r fig.width=10, fig.high=10}
today_dat %>% 
  select(starts_with("XX")) %>% 
  cor(use ="pairwise.complete.obs") %>% 
  ggcorrplot(hc.order = TRUE, tl.cex = 7)
  
```


# Re Analysis No Functions

```{r get_data2, message=FAlSE, warning=FALSE}

# libraries --------------
# devtools::install_github("zeehio/facetscales")
library(facetscales)
library(covid19census)
library(tidyverse)
library(ggcorrplot)
library(caret)
library(GGally)
library(gganimate)
library(ggcorrplot)
library(ggdendro)
library(broom)
library(purrr)
library(knitr)
library(kableExtra)
library(htmlwidgets)
library(plotly)
theme_set(theme_bw())

# var to select -------
to_select <- c(
  "date",
  "county",
  "state",
  "fips",
  "cases",
  "deaths",
  "perc_families",
  "perc_familes_18childreen",
  "perc_married_couples",
  
  "perc_family_only_onep",
  # "perc_married_couples_u18ychildreen",
  # "perc_families_only_male",
  # "perc_families_only_male__18ychildreen",
  # "perc_families_only_female",
  # "perc_families_only_female__18ychildreen",
  # "perc_non_families_alone",
  # "perc_non_families_alone65y",
  # "perc_non_families_u18y",
  # "perc_non_families_65y",
  # "perc_relationship_householder",
  # "perc_relationship_spouse",
  # "perc_relationship_child",
  # "perc_relationship_other_relatives",
  # "perc_relationship_other_nonrelatives",
  # "perc_relationship_other_unmaried_part",
  # "perc_marital_status_male_nevermaried",
  # "perc_marital_status_male_maried",
  # "perc_marital_status_male_separated",
  # "perc_marital_status_male_widowed",
  # "perc_marital_status_male_divorced",
  # "perc_marital_status_female_nevermaried",
  # "perc_marital_status_female_maried",
  # "perc_marital_status_female_separated",
  # "perc_marital_status_female_widowed",
  # "perc_marital_status_female_divorced",
  "perc_enrolled_preschool",
  "perc_enrolled_kindergarden",
  "perc_enrolled_elementary",
  "perc_enrolled_highschool",
  "perc_enrolled_college",
  # "perc_edu_9grade",
  # "perc_edu_nodiploma",
  # "perc_edu_highshool",
  "perc_edu_somecollege",
  "perc_edu_associate",
  "perc_edu_bachelor",
  # "perc_edu_gradprofess",
  # "perc_edu_highshool_higher",
  # "perc_edu_batchelor_higher",
  # "perc_american",
  # "perc_arab",
  # "perc_czech",
  # "perc_danish",
  # "perc_dutch",
  # "perc_english",
  # "perc_french_except_basque",
  # "perc_french_canadian",
  # "perc_german",
  # "perc_greek",
  # "perc_hungarian",
  # "perc_irish",
  # "perc_italian",
  # "perc_lithuanian",
  # "perc_norwegian",
  # "perc_polish",
  # "perc_portuguese",
  # "perc_russian",
  # "perc_scotch_irish",
  # "perc_scottish",
  # "perc_slovak",
  # "perc_subsaharan_african",
  # "perc_swedish",
  # "perc_swiss",
  # "perc_ukrainian",
  # "perc_welsh",
  # "perc_west_indian_excluding_hispanic_origin_groups",
  # "perc_withcomputer",
  "perc_withinternet",
  "total_pop",
  "perc_imm65",
  "total_imm65",
  "total_beds",
  
  "ratio_beds",
  "urban",
  "perc_acute_myocardial_infarction",
  "perc_alzheimer_dementia",
  "perc_asthma",
  "perc_atrial_fibrillation",
  "perc_cancer_breast",
  "perc_cancer_colorectal",
  "perc_cancer_lung",
  "perc_cancer_all",
  "perc_ch_obstructive_pulm",
  "perc_chronic_kidney_disease",
  "perc_depression",
  "perc_diabetes",
  "perc_heart_failure",
  "perc_hypertension",
  "perc_ischemic_heart_disease",
  "perc_obesity",
  "perc_osteoporosis",
  "perc_rheumatoid_arthritis",
  "perc_schizophrenia_psychotic_dis",
  "perc_stroke",
  "perc_tobacco_use",
  # to many NA for these:
  # "urgent_admission",
  # "annual_wellness_visit",
  # "elective_admission",
  # "emergent_admission",
  # "other_admission",
  # perc_pneumococcal_vaccine HIGHLY CORRELATED WITH perc_imm65
  # "perc_pneumococcal_vaccine",
  # "perc_poverty",
  "median_income",
  "pm2.5",
  "summer_temp",
  "summer_hum",
  "winter_temp",
  "winter_hum",
  "age65_over",
  "median_age",
  # "median_age_male",
  # "median_age_female",
  "sex_ratio",
  # "age_dependency",
  # "old_age_dependency",
  "child_dependency",
  "perc_black",
  "perc_lat",
  "perc_white",
  
  "perc_asian",
  "perc_island",
  "perc_other",
  "perc_two_more_races",
  "total_tests",
  "days_f0"
)

# df1   -----------------------------
df1 <- getus_all()

# df2 ------------------------------
df2 <-
  df1 %>%
  # calculate age65_over and perc_black, white and latinos, total tests
  mutate(age65_over = rowSums(dplyr::select(., matches("perc_[6][5-9]|[7|8][0-9]")))) %>%
  mutate(urban = if_else(urban == "Urban", 1, 0)) %>%
  mutate(perc_black = total_black / total_pop * 100) %>%
  mutate(perc_white = total_white / total_pop * 100) %>%
  mutate(perc_lat = total_latino / total_pop * 100) %>%
  mutate(total_tests = positive + negative) %>%

  # calculate day since first case
  mutate(f_date = case_when(cases >= 1 ~ date)) %>%
  group_by(fips) %>%
  mutate(f_date = min(f_date, na.rm = TRUE), days_f0 = as.numeric(date - f_date)) %>%
  ungroup() %>%
  mutate(days_f0 = if_else(is.finite(days_f0), days_f0, NA_real_)) %>%
  
  # newly calculated-----------------------------------  
  # total beds in ratio
  mutate(ratio_beds = total_beds/total_pop) %>% 
  # asian are here
  mutate(perc_asian = total_asian / total_pop * 100) %>%
  mutate(perc_island = total_pacific_islander / total_pop * 100) %>%
  mutate(perc_native = total_native / total_pop * 100) %>%
  mutate(perc_other = total_other_race / total_pop * 100) %>%
  mutate(perc_two_more_races = total_two_more_races / total_pop * 100) %>%
  
  
  # family with one parent together
  mutate(perc_family_only_onep = perc_families_only_female + perc_families_only_male) %>% 
  mutate(total_imm65 = age65_over/100 * perc_imm65) %>% 
   
  # select variables
  dplyr::select(!!to_select) %>%

  # perc divided by 100
  mutate_at(vars(starts_with("perc")), function(x) x / 100) %>%
  mutate(age65_over = age65_over / 100) %>%

  # we remove NAs
  na.omit() %>%

  # at least 1 death
  filter(deaths >= 1)


# all_dat -------------
all_dat <- df2 %>%
  # make variables numeric
  mutate_at(vars(
    -date, -county, -state, -fips), 
     as.numeric
  ) %>%
  # rename
  # add XX_ to all the variables excepts those
  rename_at(
    vars(
      -date, -county, -state, -fips, -cases, -deaths,
      -perc_imm65, -cases, -total_pop, -total_imm65
    ),
    ~ paste0("XX_", .)
  ) %>%
  rename_at(vars(perc_imm65), ~ paste0("ZZ_", .)) %>%
  rename_at(vars(total_imm65), ~ paste0("ZZ_", .)) %>%
  rename_at(vars(deaths), ~ paste0("YY_", .)) %>%
  rename_at(vars(cases), ~ paste0("NC_", .)) %>%
  rename_at(vars(total_pop), ~ paste0("NP_", .)) %>%
  # calculate logitZZ
  mutate(logitZZ_perc_imm65 = log(ZZ_perc_imm65) - log(1 - ZZ_perc_imm65)) %>% 
  # mutate(logitZZ_total_imm65 = log(ZZ_total_imm65) - log(1 - ZZ_total_imm65))

# today_dat ------------------------------
today_dat <- all_dat %>%
  filter(date == max(date))
```



```{r analysis_nofun, warning=FALSE}

# function
get_PPScore <- function(
                        dat = .x, 
                        filt_cases = 1,
                        # formula to use for propensity score
                        # this is a `reformulate` expression 
                        form = form_ps, 
                        # the offset of glm function
                        offset_f = "log(NC_cases)",
                        var_dep =  "YY_death",
                        # variable of interest
                        var_int = "ZZ_perc_imm65",
                        # propensity score quantile
                        quant = FALSE
                        ){

  dat <- dat %>%
    filter(dat$NC_cases >= !!filt_cases)
  
  PropScoresLM <- lm(form, data = dat)
  
  if(quant == TRUE){
    dat[, "PP"] <- cut(fitted.values(PropScoresLM), 4, labels = FALSE)
  } else {
    dat[, "PP"] <- fitted.values(PropScoresLM)
  }
  
  form_glm <- reformulate(termlabels = c(var_int, "PP"), response = var_dep)

  outcome_PP <-
    # we add on the fly PP to the dataframe and we
    dat %>%
    glm(YY_deaths ~ ZZ_perc_imm65 + PP,
        family = quasipoisson(link = "log"),
        offset = eval(parse(text = offset_f)), 
        data = .
    )

  res <- tidy(outcome_PP) %>%
    filter(term == "ZZ_perc_imm65") %>%
    mutate(
      deaths = sum(dat$NC_cases),
      n_counties = nrow(dat),
      urban = sum(dat$XX_urban)
    )
  
  
 message(
   "Applying model with filt_cases = ",
   paste0(filt_cases))
 
 res
}

# Here we select some dates, we nest the dataframe and we
# use mutate to apply the model to each nest subset.
# This is the equivalent of splitting a dataframe by date, lapply
# the formula to the list of dataframes, and cbind the results.
# dplyr + broom

dates_tostudy <- sort(unique(all_dat$date))[52:length(unique(all_dat$date))]
to_filt_cases  <- c(1, seq(10, 100, 10))                                     

zz_term <-   
  all_dat %>%
  # filter(YY_deaths > 0) %>% 
  filter(date %in% dates_tostudy) %>%
  nest(-date) %>%
  # we repeat the date slice X number of case threeshold that we want to study
  slice(rep(1:n(), each = length(to_filt_cases))) %>%
  mutate(filt_cases_c = rep(to_filt_cases, nrow(.)/length(to_filt_cases))) %>% 
  mutate(fit = 
            map2(
            data,
            filt_cases_c,
            get_PPScore,
            form = form_ps, 
            offset_f = "log(NP_total_pop)",
            quant = FALSE
            )
  ) %>% 
    unnest(fit)


# we keep a version without data that takes a lot of space
zz_term_nd <- zz_term %>% 
  select(-data)
```




```{r pscases, fig.cap="propensity score, NC_cases as offset", fig.width=4, fig.height=4, warning=FALSE}  
zz_term_nd %>%
  filter(filt_cases_c == 1) %>% 
  mutate(`urban/counties` = urban/n_counties) %>% 
  rename(`number of counties` = n_counties) %>% 
  pivot_longer(cols = 
                 c("estimate", "number of counties", "urban/counties"),
               names_to = "var_name") %>%
  mutate(sign = if_else(p.value < 0.05, "p<0.05", "NS")) %>%
  mutate(std.error = if_else(var_name == "estimate", std.error, 0)) %>% 
  
  ggplot(aes(date, value, color = sign, group = term)) +
      geom_line() +
      geom_point() +
      geom_linerange(aes(ymax = value + std.error, ymin = value - std.error), show.legend = FALSE) +
      facet_grid(vars(var_name), scales = "free") +
      scale_color_manual(values = c("NS" = "#00BFC4", "p<0.05" = "#F8766D")) +
      theme( 
        # legend.position = "top",
        legend.title = element_blank(),
        legend.box.background = element_rect(colour = "black")
      ) +
      labs(
        title = "Slope of ZZ_perc_imm65 over time",
        subtitle = "cases > 0, propensity score  using number of cases as offset"
      )
```

```{r filt_graph, fig.width=4, fig.height=4}
zz_term_nd %>%
  filter(date == max(date)) %>% 
  mutate(`urban/counties` = urban/n_counties) %>% 
  rename(`number of counties` = n_counties) %>% 
  pivot_longer(cols = 
                 c("estimate", "number of counties", "urban/counties"),
               names_to = "var_name") %>%
  mutate(sign = if_else(p.value < 0.05, "p<0.05", "NS")) %>%
  mutate(std.error = if_else(var_name == "estimate", std.error, 0)) %>% 
    
  
  ggplot(aes(filt_cases_c, value, color = sign, group = term)) +
      geom_line() +
      geom_point() +
      scale_color_manual(values = c("NS" = "#00BFC4", "p<0.05" = "#F8766D")) +
      geom_linerange(aes(ymax = value + std.error, ymin = value - std.error), show.legend = FALSE) +
      facet_grid(vars(var_name), scales = "free") +
      theme(
        # legend.position = "top",
        legend.title = element_blank(),
        legend.box.background = element_rect(colour = "black")
      ) +
      labs(
        title = paste0(max(zz_term_nd$date),": Slope of ZZ_perc_imm65"),
        subtitle = "propensity score  using number of cases as offset",
        x = "minimum cases per county to be included in analysis" 
      )
```

 